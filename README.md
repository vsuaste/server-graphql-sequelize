# Zendro GraphQL Server

Skeleton NodeJS project for a graphQL server.

This package provides a scaffold to be completed with contents generated by the [code-generator](https://github.com/Zendro-dev/graphql-server-model-codegen).

## Set up

Clone the repository and use the [Code-generator](https://github.com/ScienceDb/graphql-server-model-codegen) to dynamically generate the contents of four folders with the models information:

* models
* schemas
* resolvers
* migrations

After getting ready the generated code for the models, proceed with the server set up.

```sh
$ npm install
$ bash migrateDbAndStartServer.sh
$ npm start
```

The script ```$ migrateDbAndStartServer.sh``` will create the tables specified in the ```migrations``` folder of each database configuration, using the credentials specified in ```config/data_models_storage_config.json``` file.

_NOTE: Databases should be already configured locally in `config/data_models_storage_config.json`_.


### Environment Variables

* `PORT` - The port where the app is listening, default value is `3000`
* `ALLOW_ORIGIN` - In development mode we need to specify the header `Access-Control-Allow-Origin` so the SPA application can communicate with the server, default value is `http://localhost:8080`.
* `LIMIT_RECORDS` - Maximum number of records that each request can return, default value is 10000.
* `MAX_TIME_OUT` - Maximum number of milliseconds that a zendro server will wait to connect with another zendro server.
* `REQUIRE_SIGN_IN` - Boolean to toggle the required sign in to the graphql server

## Examples

If you followed the example for generating the code described [here](https://github.com/ScienceDb/graphql-server-model-codegen), you can try the next queries and mutations. Otherwise, just adapt the same queries and mutations for your own models generated.

We will add the next 4 people to our table ``people``.

Name (firstName) | Last Name (lastName) | Email (email)
---              | ---                  | ---
Albert           | Einstein             | albert.einstein@science.com
Thomas           | Edison               | thomas.edison@science.com
Vincent          | van Gogh             | vicent.vanGogh@art.com
Ludwig           | Beethoven            | ludwing.beethoven@art.com

#### CREATE PERSON

```
curl -XPOST http://localhost:3000/graphql -H 'Content-Type: application/graphql' -d 'mutation M { addPerson(firstName: "Albert", lastName: "Einstein", email: "albert.einstein@science.com"){ firstName email } }'
```
As result we will get `firsName` and `email` of the person just created:

```json
{
  "data": {
    "addPerson": {
      "firstName": "Albert",
      "email": "albert.einstein@science.com"
    }
  }
}
```
In the same way we add the next 3 people:

```sh
curl -XPOST http://localhost:3000/graphql -H 'Content-Type: application/graphql' -d 'mutation M { addPerson(firstName: "Thomas", lastName: "Edison", email: "thomas.edison@science.com") { firstName email } }'

curl -XPOST http://localhost:3000/graphql -H 'Content-Type: application/graphql' -d 'mutation M { addPerson(firstName: "Vicent", lastName: "van Gogh", email: "vicent.vanGogh@art.com"){ firstName email } }'

curl -XPOST http://localhost:3000/graphql -H 'Content-Type: application/graphql' -d 'mutation M { addPerson(firstName: "Ludwig", lastName: "Beethoven", email: "ludwig.beethoven@art.com"){ firstName email } }'
```

#### SEARCH PEOPLE WITH FILTER

We'll search people with 'science' as substring of their email and as result we'll get only their name and last name.

```
curl -XPOST http://localhost:3000/graphql -H 'Content-Type: application/graphql' -d '{ people(search:{field:email, value:{value:"%science%"}, operator:like}){ firstName lastName}}'
```
The result will be:

```json
{
  "data": {
    "searchPerson": [
      {
        "firstName": "Albert",
        "lastName": "Einstein"
      },
      {
        "firstName": "Thomas",
        "lastName": "Edison"
      }
    ]
  }
}
```
